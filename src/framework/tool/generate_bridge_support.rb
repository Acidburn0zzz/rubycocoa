#!/usr/bin/env ruby
# Copyright 2006 Laurent Sansonetti
# Apple Computer Inc.

require 'osx/cocoa'
require 'rexml/document'

class BridgeSupportGenerator
    class ParsingError < StandardError
        def initialize(file, line, msg)
            super("Error when parsing `#{file}' at line #{line} : #{msg}")
        end
    end

    attr_reader :signatures

    def initialize
        @interface_re = /^@interface\s+(\w+)/
        @end_re = /^@end/
        @arg_re = /^(\([^)]+\))?\s*(\w+)+$/
        @method_re = /(\w+)\s*\:\s*(\([^)]+\))?\s*\w+/

        @signatures = {}
    end

    def clear
        @signatures.clear
    end

    def parse_framework(framework)
        ['/System/Library/Frameworks', 
         '/Library/Frameworks', 
         File.join(ENV['HOME'], 'Library', 'Frameworks')].each do |path|

            fpath = File.join(path, framework + '.framework')
            if File.exists?(fpath)
                OSX::NSBundle.bundleWithPath(fpath).load
                Dir.glob(File.join(fpath, 'Headers', '**.h')).each do |header|
                    parse_header(header)
                end
                return self
            end
        end
        raise "Could not locate framework named `#{framework}'" 
    end

    def parse_header(path)
	    current_interface = nil
	    File.open(path) do |io|
	        io.each_line do |line|
	            line.strip!
	            if md = @interface_re.match(line)
	                current_interface = md[1]
	            elsif @end_re.match(line)
	                current_interface = nil
	            elsif current_interface and (line[0] == ?+ or line[0] == ?-)
                    mtype = line[0]
                    args = line.scan(@method_re)
                    next if args.size <= 1
                    selector = ""
                    passbyref_args_n = []
                    args.each_with_index do |ary, idx|
                        argname, argtype = ary
                        selector << argname << ':'
                        next if argtype.nil?
                        argtype.delete!("() \t")
                        if passbyref?(argtype) 
                            passbyref_args_n << idx
                        end 
                    end
                    unless passbyref_args_n.empty?
                        tag = mtype == ?+ ? :class_methods : :instance_methods
	                    @signatures[current_interface] ||= {}
                        h = @signatures[current_interface]
                        h[tag] ||= []
                        h[tag] << [selector, passbyref_args_n]
                    end
                end
	        end
	    end
        self
    end

    def to_xml_document
        document = REXML::Document.new
        document << REXML::XMLDecl.new
        document << REXML::Comment.new(" Generated by #{__FILE__} at #{Time.now}.")
        root = document.add_element('signatures')
        @signatures.each do |klass, hash|
            class_el = root.add_element('class')
            class_el.add_attribute('name', klass)
            hash.each { |tag, list| add_method_elements(class_el, list, tag) } 
        end
        return document
    end

    #######
    private
    #######

    def passbyref?(argtype)
        md = /^([^*]+)(\*+)$/.match(argtype)
        return false if md.nil?
        type, refkind = md[1], md[2]
        return false if type.nil? or refkind.nil?
        @objc_lookup_cache ||= {}
        @skip_objc_lookup_types ||= ['Protocol']
        cached = @objc_lookup_cache[argtype]
        return cached unless cached.nil?
        retval = if @skip_objc_lookup_types.include?(type) or OSX::NSClassFromString(type).nil?
            refkind == '*'
        else
            refkind == '**'
        end
        @objc_lookup_cache[argtype] = retval
        return retval 
    end

    def add_method_elements(class_el, list, type)
        methods_el = class_el.add_element(type.to_s)
        list.each do |selector, passbyref_args_n|
            method_el = methods_el.add_element('method')
            method_el.add_element('selector').text = selector
            passbyref_args_n.each do |i|
                method_el.add_element('by_reference_argument').text = i.to_s
            end
        end
    end
end

if ARGV.size != 1
    STDERR.puts "Usage: #{$0} <framework-name>"
    exit 1
end

generator = BridgeSupportGenerator.new
generator.parse_framework(ARGV.first)
generator.to_xml_document.write(STDOUT, 0)
puts ""
