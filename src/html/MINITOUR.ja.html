<?xml version="1.0" encoding="euc-jp" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
<head>
<title>RubyOSXOBJC-MINITOUR</title>
<meta http-equiv="Content-type" content="text/html; charset=euc-jp" />
<link href="rdtext.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1><a name="label:0" id="label:0">RubyCocoaの簡単な使い方</a></h1><!-- RDLabel: "RubyCocoaの簡単な使い方" -->
<h2><a name="label:1" id="label:1">ライブラリのロード</a></h2><!-- RDLabel: "ライブラリのロード" -->
<p>RubyCocoaのライブラリは以下のようにロードします。</p>
<pre>require 'osx/cocoa'</pre>
<p>あるいは</p>
<pre>require 'osx/foundation' # Foundationで定義されているクラスを使う
require 'osx/appkit'     # AppKitで定義されているクラスを使う</pre>
<p>のようにFoundationとAppKitのクラスを別々にロードすることもできます。</p>
<h2><a name="label:2" id="label:2">動いた実感を味わえる例</a></h2><!-- RDLabel: "動いた実感を味わえる例" -->
<p>まずは動いた実感を味わえる(音が鳴る)簡単な例です。</p>
<pre># システム音を順番に鳴らす (1) (sample/sndplay.rb)
require 'osx/cocoa'
sndfiles = `ls /System/Library/Sounds/*.aiff`.split
sndfiles.each do |path|
  snd = OSX::NSSound.alloc.initWithContentsOfFile_byReference(path, true)
  snd.play
  sleep 0.25 while snd.isPlaying?
end</pre>
<p>以降は、地味だけど理解の助けになると思われる例をあげていきます。説明の
中で "# =&gt; "の右側は実行結果として標準出力される文字列です。</p>
<h2><a name="label:3" id="label:3">OSX::OCObjectはObjective-Cオブジェクトを包むRubyオブジェクト</a></h2><!-- RDLabel: "OSX::OCObjectはObjective-Cオブジェクトを包むRubyオブジェクト" -->
<pre>p OSX::NSObject  # =&gt; #&lt;OCObject:0x82f22 class='NSObject' id=80819B0C&gt;
nobj = OSX::NSObject.alloc.init
p nobj           # =&gt; #&lt;OCObject:0x53d1a class='NSObject' id=3C6BB0&gt;</pre>
<p>RubyCocoaでは、Objective-Cオブジェクトはすべて(クラス自身も含めて)
Ruby のクラスOSX::OCObjectのインスタンスオブジェクトになります。
OSX::OCObject インスタンスはObjective-Cオブジェクトを包んだRubyオブジェ
クトということです。</p>
<h2><a name="label:4" id="label:4">すべてはRubyのオブジェクト</a></h2><!-- RDLabel: "すべてはRubyのオブジェクト" -->
<pre>p OSX::NSString.kind_of?(Class) # =&gt; false
p OSX::NSString.type            # =&gt; OSX::OCObject
p OSX::NSString.string.type     # =&gt; OSX::OCObject</pre>
<p>例えばクラスNSStringのRubyCocoaでの表現はOSX::NSStringになります。こ
の場合OSX::NSStringは、RubyオブジェクトとしてはOSX::OCObjectクラスのイ
ンスタンスであってクラスそのものではないことに注意してください。</p>
<h2><a name="label:5" id="label:5">オブジェクトの生成とオーナーシップ</a></h2><!-- RDLabel: "オブジェクトの生成とオーナーシップ" -->
<p>OSX::OCObjectのオブジェクト生成は、Cocoa/Objective-Cのメソッドをそのま
ま使います。OSX::OCObjectのインスタンスはかならず自身が包んでいる
Objective-Cオブジェクトのオーナーシップを持ちます。オーナーシップはオ
ブジェクトがGCに掃除されるときに自動的になくなりますので気にする必要は
ありません。</p>
<pre>OSX::NSString.alloc.initWithString "Hoge"
OSX::NSString.alloc.stringWithString "Hoge"</pre>
<p>上記２行は、Objective-Cではオーナーシップを発生させるかさせないかとい
う違いがありますが、RubyCocoa ではたいして違いがありません。release、
autorelease、retainなどのメソッドは基本的に呼ぶ必要はありませんし、
NSAutoreleasePoolを作る必要もありません。</p>
<ul>
<li>OSX::OCObjectオブジェクトはCocoaのメソッドで生成する</li>
<li>できたオブジェクトはRubyのGCが管理するので作りっぱなしで良い</li>
</ul>
<h2><a name="label:6" id="label:6">メソッドの返す値</a></h2><!-- RDLabel: "メソッドの返す値" -->
<pre>nstr = OSX::NSString.description
p nstr      # =&gt; #&lt;OCObject:0x7233e class='NSCFString' id=687610&gt;
p nstr.to_s # =&gt; "NSString"

nstr = OSX::NSString.stringWithString "Hello World !"
p nstr      # =&gt; #&lt;OCObject:0x71970 class='NSCFString' id=688E90&gt;
p nstr.to_s # =&gt; "Hello World !"

nstr = OSX::NSString.stringWithString(`pwd`.chop)
nary = nstr.pathComponents
p nary      # =&gt; #&lt;OCObject:0x6bb2e class='NSCFArray' id=3C0150&gt;

ary = nary.to_a
p ary       # =&gt; [#&lt;OCObject:0x6a9b8 class='NSCFString' id=3C2B50&gt;,...]

ary.map! {|i| i.to_s }
p ary       # =&gt; ["/", "Users", "hisa", "src", "ruby", "osxobjc"]</pre>
<p>これらの例から推測できるようにRubyCocoaでは、NSStringやNSArrayなど
Objective-Cオブジェクトを返すメソッドをOSX::OCObjectのインスタンスとし
て返します。積極的にRubyの対応するオブジェクト(例えばStringなど)には変
換しません。文字列と配列に関しては to_s や to_a が定義されているのでそ
れを使うことができます。</p>
<h2><a name="label:7" id="label:7">メソッド名の決定方法とバリエーション</a></h2><!-- RDLabel: "メソッド名の決定方法とバリエーション" -->
<pre># システム音を順番に鳴らす (2)
sndfiles.each do |path|
  snd = OSX::NSSound.alloc.initWithContentsOfFile(path, :byReference, true)
  snd.play
  sleep 0.25 while snd.isPlaying?
end</pre>
<p>これはさきほど示した音をならす例の別バージョンです。Objective-Cのメッ
セージセレクタと引数をRuby風に表記する別の方法を示しています。
Objective-Cの</p>
<pre>[obj hogeAt: a0 withParamA: a1 withParamB: a2]</pre>
<p>に対していくつかの呼び出し方法が用意されています。基本は、メッセージセ
レクタの":"を"_"に置き換えたものがRuby側でのメソッド名となります。</p>
<pre>obj.hogeAt_withParamA_withParamB_ (a0, a1, a2)</pre>
<p>ただし、このままではカッコ悪すぎなので最後の"_"は省略することができま
す。</p>
<pre>obj.hogeAt_withParamA_withParamB (a0, a1, a2)</pre>
<p>また長いメソッド名の場合など、メッセージセレクタのキーワードと引数の関
係がわかりにくいため、あまり美しくありませんが、苦肉の策として次のよう
な方法も使うことができます。</p>
<pre>obj.hogeAt (a0, :withParamA, a1, :withParamB, a2)</pre>
<p>BOOLを返すメソッド(述語)の場合には、メソッド名の最後に"?"を付けてくだ
さい。RubyCocoaでは、'?'の有無でメソッドが論理値を返すものかどうか判
断しています。付けない場合にはObjective-Cが返した数値(0:NO, 1:YES)が返
りますが、これらの値はRuby の論理値としてどちらも真になります。</p>
<pre>nary = OSX::NSMutableArray.alloc.init
p nary.containsObject("hoge")   # =&gt; 0
p nary.containsObject?("hoge")  # =&gt; false
nary.addObject("hoge")
p nary.containsObject("hoge")   # =&gt; 1
p nary.containsObject?("hoge")  # =&gt; true</pre>
<h2><a name="label:8" id="label:8">メソッドの引数は可能な限り変換する</a></h2><!-- RDLabel: "メソッドの引数は可能な限り変換する" -->
<p>上の例のcontainsObjectのように、引数の値としてObjective-Cオブジェクト
をとるメソッドの場合に、Rubyオブジェクトをそのまま渡しても可能な限り変
換を試みます。</p>
<h2><a name="label:9" id="label:9">メソッド名が重複するときに使う接頭辞 "oc_"</a></h2><!-- RDLabel: "メソッド名が重複するときに使う接頭辞 "oc_"" -->
<pre>klass = OSX::NSObject.class
p klass     # =&gt; OSX::OCObject
klass = OSX::NSObject.oc_class
p klass     # =&gt; #&lt;OCObject:0x82f22 class='NSObject' id=80819B0C&gt;</pre>
<p>"Object#class"のようにRubyとObjective-Cでメソッド名(セレクタ)が全く同
じ場合には、Rubyのメソッドが呼ばれます。このような場合には、メソッド名
の頭に"oc_"という接頭辞をつけると、Objective-Cオブジェクトに対してメッ
セージが送られます。"oc_" を付けてもRuby側にメソッドがある場合は？どう
しようもありません(裏技はあるのでソースを読める人はどうぞ) 。</p>
<p>藤本尚邦 FUJIMOTO Hisakuni &lt;hisa@imasy.or.jp&gt;
$Date$ : $Revision$</p>

</body>
</html>
