<?xml version="1.0" encoding="us-ascii" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>RubyCocoa - MINITOUR</title>
<meta http-equiv="Content-type" content="text/html; charset=us-ascii" />
<link href="rdtext.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1><a name="label:0" id="label:0">Using RubyCocoa</a></h1><!-- RDLabel: "Using RubyCocoa" -->
<h2><a name="label:1" id="label:1">load libraries</a></h2><!-- RDLabel: "load libraries" -->
<pre>require 'osx/cocoa'      # classes defined in Foundation and AppKit.</pre>
<p>or</p>
<pre>require 'osx/foundation' # classes defined in Foundation
require 'osx/appkit'     # classes defined in AppKit</pre>
<h2><a name="label:2" id="label:2">an example the action with feeling</a></h2><!-- RDLabel: "an example the action with feeling" -->
<p>At first it is a simple example to can taste the actual feeling that
changed (a sound sounds).</p>
<pre># play system sounds (1) (sample/sndplay.rb)
require 'osx/cocoa'
sndfiles = `ls /System/Library/Sounds/*.aiff`.split
sndfiles.each do |path|
  snd = OSX::NSSound.alloc.initWithContentsOfFile_byReference(path, true)
  snd.play
  sleep 0.25 while snd.isPlaying?
end</pre>
<p>Below, the right side of "# =&gt;" is character string done standard
output of as an execution result in description.</p>
<h2><a name="label:3" id="label:3">Cocoa class</a></h2><!-- RDLabel: "Cocoa class" -->
<pre>p OSX::NSObject # =&gt; OSX::NSObject
nsstr = OSX::NSObject.description
p nsstr         # =&gt; #&lt;OSX::OCObject:0x5194e8 class='NSCFString' id=A97910&gt;
nsobj = OSX::NSObject.alloc.init
p nsobj         # =&gt; #&lt;OSX::NSObject:0x51f5b4 class='NSObject' id=976D90&gt;</pre>
<p>In RubyCocoa, a Cocoa class is defined as a Ruby's Class under OSX
module (after 0.2.0). A Cocoa class is a Ruby's Class and behaves as
object of Cocoa.</p>
<h2><a name="label:4" id="label:4">create a Cocoa object</a></h2><!-- RDLabel: "create a Cocoa object" -->
<p>The method of Cocoa is used for creation of a Cocoa object as it is.</p>
<pre>obj = OSX::NSObject.alloc.init
str = OSX::NSString.stringWithString "hello"
str = OSX::NSString.alloc.initWithString "world"</pre>
<p>The created Cocoa object is wrapped in the object of a class called
OSX::ObjcID inside RubyCocoa. Usually, You don't need to be conscious
of existence of an OSX::ObjcID class.</p>
<h2><a name="label:5" id="label:5">onwership and memory management</a></h2><!-- RDLabel: "onwership and memory management" -->
<p>The instance of OSX::ObjcID surely has the ownership of the Cocoa
object which self has wrapped. Ownership is automatically lost, when
the instance of OSX::ObjcID is cleaned by GC. Therefore, it is not
necessary to care about memory management of ownership etc. in
RubyCocoa.</p>
<pre>str = OSX::NSObject.stringWithString "hello"
str = OSX::NSObject.alloc.initWithString "world"</pre>
<p>Although the two above-mentioned lines have difference whether
ownership is generated or it carries out, in Objective-C, there is no
necessity that he is conscious of ownership. In RubyCocoa, there is no
difference so much. It is not necessary to call methods, such as
release, autorelease, and retain, fundamentally, and they do not need
to make NSAutoreleasePool.</p>
<ul>
<li>use Cocoa method for creating a Cocoa object</li>
<li>don't worry ownership and memory management.</li>
</ul>
<h2><a name="label:6" id="label:6">return value of method</a></h2><!-- RDLabel: "return value of method" -->
<pre>nstr = OSX::NSString.description
p nstr      # =&gt; #&lt;OCObject:0x7233e class='NSCFString' id=687610&gt;
p nstr.to_s # =&gt; "NSString"

nstr = OSX::NSString.stringWithString "Hello World !"
p nstr      # =&gt; #&lt;OCObject:0x71970 class='NSCFString' id=688E90&gt;
p nstr.to_s # =&gt; "Hello World !"

nstr = OSX::NSString.stringWithString(`pwd`.chop)
nary = nstr.pathComponents
p nary      # =&gt; #&lt;OCObject:0x6bb2e class='NSCFArray' id=3C0150&gt;

ary = nary.to_a
p ary       # =&gt; [#&lt;OCObject:0x6a9b8 class='NSCFString' id=3C2B50&gt;,...]

ary.map! {|i| i.to_s }
p ary       # =&gt; ["/", "Users", "hisa", "src", "ruby", "osxobjc"]</pre>
<p>In RubyCocoa, the method which returns Objective-C objects, such as
NSString and NSArray, is returned as a Cocoa object so that it can
guess from these examples. It does not change into the object to which
Ruby corresponds positively (for example, String etc.). For a NSString
and NSArray, "to_s" and "to_a" is defined, it can be used.</p>
<h2><a name="label:7" id="label:7">A decision and a variation of method name</a></h2><!-- RDLabel: "A decision and a variation of method name" -->
<pre># play system sounds (2)
sndfiles.each do |path|
  snd = OSX::NSSound.alloc.initWithContentsOfFile(path, :byReference, true)
  snd.play
  sleep 0.25 while snd.isPlaying?
end</pre>
<p>This is another version of "playing system sounds". This show the
other way of representation Objective-C Message Selector in Ruby
world.</p>
<p>As Objective-C:</p>
<pre>[obj hogeAt: a0 withParamA: a1 withParamB: a2]</pre>
<p>The RubyCocoa prepare some message sending way. Most basic way is
substitute ":" with "_".</p>
<pre>obj.hogeAt_withParamA_withParamB_ (a0, a1, a2)</pre>
<p>But this appearance is too bad, so you can omit the last "_".</p>
<pre>obj.hogeAt_withParamA_withParamB (a0, a1, a2)</pre>
<p>When method name is very long, the relation Message Selector Keyword
and each arguments is unclear. In order to improve this </p>
<pre>obj.hogeAt (a0, :withParamA, a1, :withParamB, a2)</pre>
<p>For the method returned BOOL (predicate method), using method name
suffix "?".  If nothing this, method will return value 0(NO) or
1(YES). These values behave as the true in the Ruby World.</p>
<pre>nary = OSX::NSMutableArray.alloc.init
p nary.containsObject("hoge")   # =&gt; 0
p nary.containsObject?("hoge")  # =&gt; false
nary.addObject("hoge")
p nary.containsObject("hoge")   # =&gt; 1
p nary.containsObject?("hoge")  # =&gt; true</pre>
<h2><a name="label:8" id="label:8">convert Ruby object argument of method as possible</a></h2><!-- RDLabel: "convert Ruby object argument of method as possible" -->
<p>It seems to be usual containsObject of the top and, in case of method
to catch Objective-C object as a value of argument, tries conversion
even if it just hands Ruby object so long as it is possible.</p>
<h2><a name="label:9" id="label:9">method name prefix "oc_" - using this when method name conflict</a></h2><!-- RDLabel: "method name prefix "oc_" - using this when method name conflict" -->
<pre>klass = OSX::NSObject.class
p klass     # =&gt; OSX::OCObject
klass = OSX::NSObject.oc_class
p klass     # =&gt; #&lt;OCObject:0x82f22 class='NSObject' id=80819B0C&gt;</pre>
<p>When the case same method name in Ruby and Objective-C like
"Object#class", use method name prefix "oc_".</p>
<h2><a name="label:10" id="label:10">inherited class and its instance of a Cocoa class</a></h2><!-- RDLabel: "inherited class and its instance of a Cocoa class" -->
<p>The topic about the existing Cocoa class and its instance was treated
so far. From here, the topic about the definition of the Cocoa
inherited class which is needed when writing RubyCocoa application, or
its instance is treated. Since a little tricky mounting has realized,
although the inherited class of Cocoa has some restrictions and
peculiarities, let's see also including it.</p>
<h2><a name="label:11" id="label:11">The definition of a Cocoa inherited class</a></h2><!-- RDLabel: "The definition of a Cocoa inherited class" -->
<p>The class of the Cocoa object set up in the GUI definition file (nib
file) created by Interface Builder etc. is defined as an inherited
class (after 0.2.0). For example, the controller of a MVC model which
comes out to the first direction by a primer, a tutorial, etc. of
Cocoa is defined like ...</p>
<pre>class AppController &lt; OSX::NSObject

  ib_outlets :messageField

  def btnClicked(sender)
  end

end</pre>
<p>The inherited class definition of Cocoa in RubyCocoa is similarly
described to be the inherited class definition by the usual Ruby in
this way.</p>
<h2><a name="label:12" id="label:12">Outlet</a></h2><!-- RDLabel: "Outlet" -->
<p>The outlet set as the class in the nib file is written to be:</p>
<pre>ns_outlets :rateField, :dollerField</pre>
<p>in the definition of an inherited class. In fact, ns_outlets is the
same as Module#attr_writer. Therefore, a definition can also be
instead given like:</p>
<pre>def rateField= (new_val)
  @rateField = new_val
end</pre>
<p>ns_outlets has also an alias called ib_outlets.</p>
<h2><a name="label:13" id="label:13">The override of a method</a></h2><!-- RDLabel: "The override of a method" -->
<p>When overriding the method defined by the parent class, it is
necessary to declare having overridden using ns_overrides (alias
ib_overrides).</p>
<pre>class MyCustomView &lt; OSX::NSView

  ns_overrides :drawRect_, 'mouseUp:'

  def drawRect(frame)
  end

  ...
end</pre>
<p>In the argument of ns_overrides what expressed the message selector of
Objective-C as the string or the symbol is given. However, the
notation for omitting ":" and "_" of the end explained previously
cannot be used. It is necessary to describe correctly according to the
number of arguments.</p>
<p>Furthermore, overriding of the method of a Cocoa inherited class has
severe restrictions. The same name method of a parent class cannot be
called out of the method which is overriding. For example, if the
following ways of writing are adopted, rotation of a method call will
occur.</p>
<pre>class MyCustomView &lt; OSX::NSView

  ns_overrides :initWithFrame_

  def initWithFrame(frame)
    ...
    super(frame)
  end

end</pre>
<p>Although I want to solve in the future since existence of these
restrictions is inconvenient, there is no solution method effective
for the moment.</p>
<h2><a name="label:14" id="label:14">create an instance of a Cocoa inherited class</a></h2><!-- RDLabel: "create an instance of a Cocoa inherited class" -->
<p>When the instance of a Cocoa inherited class needs to be created in a
Ruby script, it writes like:</p>
<pre>AppController.alloc.init</pre>
<p>like the case of the existing Cocoa class. The most general way of
writing in Ruby:</p>
<pre>AppControll.new</pre>
<p>cannot be used (it is made to raise the exception). Although there are
various situations in this, since it becomes long, detailed
explanation is omitted here.</p>
<p>These restrictions have deep relation in instance generation being
performed in the turn:</p>
<ul>
<li>alloc (in Objective-C world)</li>
<li>in alloc, create a Ruby object (initialize method is called here)</li>
</ul>
<h2><a name="label:15" id="label:15">Where should the initialization code at the time of instance generation be written?</a></h2><!-- RDLabel: "Where should the initialization code at the time of instance generation be written?" -->
<h2><a name="label:16" id="label:16">Where should an initialization code be written?</a></h2><!-- RDLabel: "Where should an initialization code be written?" -->
<p>Although the code of initialization is generally written into an
"initialize" method by Ruby, if it says in which, I will seldom be
recommended by the Cocoa inherited class. A reason is not initialized
only by a memory being assigned as a Cocoa object at the time by the
timing which the initialize method at the time of the instance
generation described previously is called. However, it is thought that
especially a problem is not generated in the limitation which does not
call the Cocoa side method.</p>
<p>In the case so that it may be loaded from a nib file initializing by
the "awakeFromNib" method is safest. Doesn't that it is also necessary
to actually define the inherited class of Cocoa have most these cases?</p>
<p>In the case of others, it is in the style of Cocoa "init" Probably,
writing to a method with a prefix will be good. Please do not forget
for a method to return "self".</p>
<p>FUJIMOTO Hisakuni &lt;hisa@imasy.or.jp&gt;
$Date$ $Revision$</p>

</body>
</html>
