<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Language" content="en-US">
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>RubyCocoa 1.0 Sneak Preview</title>
</head>
<body>
<h1>RubyCocoa 1.0 Sneak Preview</h1>


	<p>This page is available in <a href="index-ja.html">Japanese</a>.</p>


	<p>This web page describes the current status of the RubyCocoa unstable branch, which aims to become the code base of the future 1.0 release.</p>


	<p>For the moment, even we are still heavily working on it, the new code base is mostly functional and sometimes even more reliable than the stable release. So you are graciously invited to test it and report any problem you would find.</p>


	<h2>Getting Started</h2>


	<p>The latest pre-release available is 0.10.1. Please check out either the binary installer or the source tarball from <a href="http://sourceforge.net/project/showfiles.php?group_id=44114">the download page</a>.</p>


	<p>If you downloaded the source tarball, you need to build the project manually:</p>


<pre>
$ cd rubycocoa-unstable
$ ruby install.rb config
$ ruby install.rb setup
$ sudo ruby install.rb install
</pre>

	<p>You can retrieve the latest version of the source tree via <span class="caps">SVN</span>:</p>


<pre>
$ svn co https://rubycocoa.svn.sourceforge.net/svnroot/rubycocoa/branches/apple-unstable/src \
    rubycocoa-unstable
</pre>

	<p>Once RubyCocoa will be installed you will find sample projects in <tt>/Developer/Examples/RubyCocoa</tt>. There is a convenient script that builds all the samples for you:</p>


<pre>
$ cd /Developer/Examples/RubyCocoa
$ mkdir All
$ ruby buildall.rb All
$ open All
</pre> 

	<h2>What&#8217;s New</h2>


	<p>The unstable branch contains lots of fixes and improvements. Let&#8217;s describe the most important changes.</p>


	<h3>Libffi Integration</h3>


	<p><a href="http://sources.redhat.com/libffi/">Libffi</a> support has been added to RubyCocoa. <span class="caps">FFI</span> stands for Foreign Function Interface. It is a C library, part of the <span class="caps">GCC</span> project, that can call any arbitrary C function, packing the parameters and retrieving the return value in a processor and variable-type agnostic way.</p>


	<p>RubyCocoa is using it in several places when messages are dispatched within the 2 worlds, for instance when you call a C function from Ruby or message an Objective-C object from Ruby, but also when a custom Ruby object crosses the bridge and is messaged by Objective-C.</p>


	<p>The usage of Libffi in RubyCocoa brings reliability and enhances the performance. RubyCocoa no longer uses <tt>NSInvocation</tt> anymore.</p>


	<h3>BridgeSupport Metadata</h3>


	<p>Thanks to the dynamic nature of Objective-C, most of the information that needs to be bridged can be retrieved at runtime, such as the classes and their methods. However, in Objective-C there is C, which isn&#8217;t as dynamic. There is no way to introspect at runtime the pure C data like functions and constants.</p>


	<p>RubyCocoa used to handle the C bits of frameworks by parsing the headers and generating some static code at build time. But this became hard to maintain as you have to rebuild the bridge to support a new framework. Thus the idea to modify Rubycocoa to be metadata-driven. Instead of generating static code, we generate metadata files and RubyCocoa interprets them at runtime.</p>


	<p>We have a metadata generator that is ran at build time to produce metadata information for a set of default frameworks. The metadata format is <span class="caps">XML</span>. We generate a file per framework. Metadata describes C functions, enumerations, constants, structures but also opaque and CoreFoundation-based types, and Objective-C informal protocol methods. The metadata also provides a better description of methods returning a boolean value and accepting pointer-like arguments.</p>


	<p>RubyCocoa loads the files at runtime, after that a framework has been loaded. It tries to interpret the contents in a lazy way, for example localizing the symbols only on demand. The metadata generator is installed as <tt>/usr/bin/gen_bridge_metadata</tt> and is aimed to be used outside to support more frameworks. The metadata files are installed in <tt>/Library/BridgeSupport</tt>.</p>


	<h3>More Frameworks Support</h3>


	<p>Thanks to the new metadata mechanism we are now able to bridge frameworks more easily than previously. In addition to Foundation, AppKit and WebKit, the unstable branch also provides support for CoreFoundation, CoreGraphics, PDFKit, QuartzCore (CoreImage and CoreVideo), OpenGL, QTKit, AddressBook and InstantMessage. The previous support of CoreData has been ported to be metadata-driven. We are adding more support progressively.</p>


	<p>Sample code using these frameworks is available in <tt>/Developer/Examples/RubyCocoa</tt>.</p>


	<h3><span class="caps">API</span> Changes</h3>


	<p>RubyCocoa allows you to omit the final underscore character when dispatching a message from Ruby to Objective-C. This is still supported, though this is no longer permitted if the <tt><span class="caps">OSX</span>.relaxed_syntax</tt> variable is set to <tt>false</tt> (which is set to <tt>true</tt> by default).</p>


<pre>
p OSX.relaxed_syntax                # returns true
OSX::Array.arrayWithObject('foo')   # OK
OSX.relaxed_syntax = false
OSX::Array.arrayWithObject('foo')   # Exception! 
OSX::Array.arrayWithObject_('foo')  # OK
</pre> 

	<p>When sending messages from Ruby to Objective-C, the <i>symbol / value&#8230;</i> syntax has been deprecated. A warning will now be printed each time you are using this syntax, and in the final release an exception will be thrown.</p>


<pre>
OSX::NSURL.alloc.initWithScheme('http', :host, 'www.apple.com', :path, '/macosx')  # BAD
OSX::NSURL.alloc.initWithScheme_host_path('http', 'www.apple.com', '/macosx')      # GOOD
</pre>

	<p>As an alternative, we introduced a new method, <tt>objc_send</tt>:</p>


<pre>
OSX::NSURL.alloc.objc_send(:initWithScheme, 'http',
                           :host,           'www.apple.com',
                           :path,           '/macosx')
</pre>

	<p>RubyCocoa now maps C constants as real Ruby constants of the <span class="caps">OSX</span> module, while before it was mapping them as Ruby methods. Trying to retrieve a constant by calling a method of the <span class="caps">OSX</span> module has been deprecated. A warning will now be printed each time you are using this syntax, and in the final release an exception will be thrown.</p>


<pre>
OSX.NSApp    # BAD
OSX.NSApp()  # BAD
OSX::NSApp   # GOOD
</pre>

	<p>You may perhaps know about <tt>addRubyMethod_withType</tt>. This method lets you register a Ruby method into the Objective-C runtime. However, you need to pass to this method its Objective-C name (as a <i>selector</i>) as well as its Objective-C encoding, which may not be very easy to determine if you are not an experienced Objective-C programmer (only a few know the Objective-C runtime constants by heart). As an alternative, we introduced <tt>objc_export</tt> which has a more friendly interface:</p>


<pre>
class MyClass : NSObject
  # A method returning an 'id'.
  def something
    'something'
  end
  objc_export :something, %w{id}

  # A method accepting 2 integers and returning the sum of them.
  def sum_with(x, y)
    x + y
  end
  objc_export :sum_with, %w{int int int}

  # A method accepting an NSPoint and NSSize, and returning an NSRect.
  def makeRectWithPoint_size(point, size)
    NSRect.new(point, size)
  end
  objc_export :makeRectWithPoint_size, [NSRect, NSPoint, NSSize]
end
</pre>

	<h3>More Runtime Power</h3>


	<p>It is now possible to add or override Objective-C methods directly to a given class, as you would do in Objective-C using a category. In previous versions of RubyCocoa this was only possible in subclasses.</p>


	<p>An example demonstrating the injection of a new method:</p>


<pre>
class NSObject
  def myMethod
    # Do something
    'foo'
  end
  objc_export :myMethod, ['id']
end

# Now, all NSObject-based objects in the Objective-C runtime will respond to [-myMethod]. 
</pre>

	<p>And another one overriding an existing method:</p>


<pre>
class NSString
  def length
    42
  end
end

# Now, all NSString objects will have a length of 42. Don't try this at home kids!
</pre>

	<h2>Support</h2>


	<p>For the moment please send your feedback to the <a href="http://lists.sourceforge.jp/mailman/listinfo/rubycocoa-devel">rubycocoa-devel</a> mailing list, in the meantime we put in place a dedicated bug tracker.</p>